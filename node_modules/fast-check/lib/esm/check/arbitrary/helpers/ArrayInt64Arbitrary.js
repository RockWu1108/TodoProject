import { stream } from '../../../stream/Stream.js';
import { ArbitraryWithShrink } from '../definition/ArbitraryWithShrink.js';
import { biasWrapper } from '../definition/BiasedArbitraryWrapper.js';
import { Shrinkable } from '../definition/Shrinkable.js';
import { add64, halve64, isEqual64, isStrictlyNegative64, isStrictlyPositive64, isZero64, logLike64, substract64, Zero64, } from './ArrayInt64.js';
import { BiasedNumericArbitrary } from './BiasNumeric.js';
class ArrayInt64Arbitrary extends ArbitraryWithShrink {
    constructor(min, max, genMin, genMax) {
        super();
        this.min = min;
        this.max = max;
        this.genMin = genMin;
        this.genMax = genMax;
        this.biasedArrayInt64Arbitrary = null;
    }
    wrapper(value, shrunkOnce) {
        return new Shrinkable(value, () => this.shrink(value, shrunkOnce).map((v) => this.wrapper(v, true)));
    }
    generate(mrng) {
        const uncheckedValue = mrng.nextArrayInt(this.genMin, this.genMax);
        if (uncheckedValue.data.length === 1) {
            uncheckedValue.data.unshift(0);
        }
        return this.wrapper(uncheckedValue, false);
    }
    shrinkValueTowards(value, target, shrunkOnce) {
        const realGap = substract64(value, target);
        function* shrinkGen() {
            const gap = shrunkOnce ? halve64(realGap) : realGap;
            for (let toremove = gap; !isZero64(toremove); toremove = halve64(toremove)) {
                yield substract64(value, toremove);
            }
        }
        return stream(shrinkGen());
    }
    shrink(value, shrunkOnce) {
        if (!isStrictlyPositive64(this.min) && !isStrictlyNegative64(this.max)) {
            return this.shrinkValueTowards(value, Zero64, shrunkOnce);
        }
        if (isStrictlyNegative64(value)) {
            return this.shrinkValueTowards(value, this.max, shrunkOnce);
        }
        return this.shrinkValueTowards(value, this.min, shrunkOnce);
    }
    pureBiasedArbitrary() {
        if (this.biasedArrayInt64Arbitrary != null) {
            return this.biasedArrayInt64Arbitrary;
        }
        if (isEqual64(this.min, this.max)) {
            this.biasedArrayInt64Arbitrary = this;
            return this;
        }
        const minStrictlySmallerZero = isStrictlyNegative64(this.min);
        const maxStrictlyGreaterZero = isStrictlyPositive64(this.max);
        if (minStrictlySmallerZero && maxStrictlyGreaterZero) {
            const logMin = logLike64(this.min);
            const logMax = logLike64(this.max);
            this.biasedArrayInt64Arbitrary = new BiasedNumericArbitrary(new ArrayInt64Arbitrary(this.min, this.max, logMin, logMax), new ArrayInt64Arbitrary(this.min, this.max, substract64(this.max, logMax), this.max), new ArrayInt64Arbitrary(this.min, this.max, this.min, substract64(this.min, logMin)));
        }
        else {
            const logGap = logLike64(substract64(this.max, this.min));
            const arbCloseToMin = new ArrayInt64Arbitrary(this.min, this.max, this.min, add64(this.min, logGap));
            const arbCloseToMax = new ArrayInt64Arbitrary(this.min, this.max, substract64(this.max, logGap), this.max);
            this.biasedArrayInt64Arbitrary = minStrictlySmallerZero
                ? new BiasedNumericArbitrary(arbCloseToMax, arbCloseToMin)
                : new BiasedNumericArbitrary(arbCloseToMin, arbCloseToMax);
        }
        return this.biasedArrayInt64Arbitrary;
    }
    withBias(freq) {
        return biasWrapper(freq, this, (originalArbitrary) => originalArbitrary.pureBiasedArbitrary());
    }
}
export function arrayInt64(min, max) {
    return new ArrayInt64Arbitrary(min, max, min, max);
}
