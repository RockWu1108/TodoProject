import { option } from './OptionArbitrary.js';
import { genericTuple } from './TupleArbitrary.js';
function rawRecord(recordModel) {
    const keys = Object.keys(recordModel);
    const arbs = keys.map((v) => recordModel[v]);
    return genericTuple(arbs).map((gs) => {
        const obj = {};
        for (let idx = 0; idx !== keys.length; ++idx)
            obj[keys[idx]] = gs[idx];
        return obj;
    });
}
function record(recordModel, constraints) {
    if (constraints == null || constraints.withDeletedKeys !== true) {
        return rawRecord(recordModel);
    }
    const updatedRecordModel = {};
    for (const k of Object.keys(recordModel))
        updatedRecordModel[k] = option(recordModel[k].map((v) => ({ value: v })));
    return rawRecord(updatedRecordModel).map((obj) => {
        const nobj = {};
        for (const k of Object.keys(obj)) {
            if (obj[k] != null)
                nobj[k] = obj[k].value;
        }
        return nobj;
    });
}
export { record };
