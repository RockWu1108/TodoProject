import { Arbitrary } from './definition/Arbitrary';
/**
 * Constraints to be applied on {@link record}
 * @public
 */
export interface RecordConstraints {
    /** Allow to remove keys from the generated record */
    withDeletedKeys?: boolean;
}
/**
 * Infer the type of the Arbitrary produced by record
 * given the type of the source arbitrary and constraints to be applied
 * @public
 */
export declare type RecordValue<T, Constraints = {}> = Constraints extends {
    withDeletedKeys: true;
} ? Partial<T> : T;
/**
 * For records following the `recordModel` schema
 *
 * @example
 * ```typescript
 * record({ x: someArbitraryInt, y: someArbitraryInt }): Arbitrary<{x:number,y:number}>
 * // merge two integer arbitraries to produce a {x, y} record
 * ```
 *
 * @param recordModel - Schema of the record
 *
 * @public
 */
declare function record<T>(recordModel: {
    [K in keyof T]: Arbitrary<T[K]>;
}): Arbitrary<RecordValue<{
    [K in keyof T]: T[K];
}>>;
/**
 * For records following the `recordModel` schema
 *
 * @example
 * ```typescript
 * record({ x: someArbitraryInt, y: someArbitraryInt }, {withDeletedKeys: true}): Arbitrary<{x?:number,y?:number}>
 * // merge two integer arbitraries to produce a {x, y}, {x}, {y} or {} record
 * ```
 *
 * @param recordModel - Schema of the record
 * @param constraints - Contraints on the generated record
 *
 * @public
 */
declare function record<T, Constraints extends RecordConstraints>(recordModel: {
    [K in keyof T]: Arbitrary<T[K]>;
}, constraints: Constraints): Arbitrary<RecordValue<{
    [K in keyof T]: T[K];
}, Constraints>>;
export { record };
