"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.arrayInt64 = void 0;
const Stream_1 = require("../../../stream/Stream");
const ArbitraryWithShrink_1 = require("../definition/ArbitraryWithShrink");
const BiasedArbitraryWrapper_1 = require("../definition/BiasedArbitraryWrapper");
const Shrinkable_1 = require("../definition/Shrinkable");
const ArrayInt64_1 = require("./ArrayInt64");
const BiasNumeric_1 = require("./BiasNumeric");
class ArrayInt64Arbitrary extends ArbitraryWithShrink_1.ArbitraryWithShrink {
    constructor(min, max, genMin, genMax) {
        super();
        this.min = min;
        this.max = max;
        this.genMin = genMin;
        this.genMax = genMax;
        this.biasedArrayInt64Arbitrary = null;
    }
    wrapper(value, shrunkOnce) {
        return new Shrinkable_1.Shrinkable(value, () => this.shrink(value, shrunkOnce).map((v) => this.wrapper(v, true)));
    }
    generate(mrng) {
        const uncheckedValue = mrng.nextArrayInt(this.genMin, this.genMax);
        if (uncheckedValue.data.length === 1) {
            uncheckedValue.data.unshift(0);
        }
        return this.wrapper(uncheckedValue, false);
    }
    shrinkValueTowards(value, target, shrunkOnce) {
        const realGap = ArrayInt64_1.substract64(value, target);
        function* shrinkGen() {
            const gap = shrunkOnce ? ArrayInt64_1.halve64(realGap) : realGap;
            for (let toremove = gap; !ArrayInt64_1.isZero64(toremove); toremove = ArrayInt64_1.halve64(toremove)) {
                yield ArrayInt64_1.substract64(value, toremove);
            }
        }
        return Stream_1.stream(shrinkGen());
    }
    shrink(value, shrunkOnce) {
        if (!ArrayInt64_1.isStrictlyPositive64(this.min) && !ArrayInt64_1.isStrictlyNegative64(this.max)) {
            return this.shrinkValueTowards(value, ArrayInt64_1.Zero64, shrunkOnce);
        }
        if (ArrayInt64_1.isStrictlyNegative64(value)) {
            return this.shrinkValueTowards(value, this.max, shrunkOnce);
        }
        return this.shrinkValueTowards(value, this.min, shrunkOnce);
    }
    pureBiasedArbitrary() {
        if (this.biasedArrayInt64Arbitrary != null) {
            return this.biasedArrayInt64Arbitrary;
        }
        if (ArrayInt64_1.isEqual64(this.min, this.max)) {
            this.biasedArrayInt64Arbitrary = this;
            return this;
        }
        const minStrictlySmallerZero = ArrayInt64_1.isStrictlyNegative64(this.min);
        const maxStrictlyGreaterZero = ArrayInt64_1.isStrictlyPositive64(this.max);
        if (minStrictlySmallerZero && maxStrictlyGreaterZero) {
            const logMin = ArrayInt64_1.logLike64(this.min);
            const logMax = ArrayInt64_1.logLike64(this.max);
            this.biasedArrayInt64Arbitrary = new BiasNumeric_1.BiasedNumericArbitrary(new ArrayInt64Arbitrary(this.min, this.max, logMin, logMax), new ArrayInt64Arbitrary(this.min, this.max, ArrayInt64_1.substract64(this.max, logMax), this.max), new ArrayInt64Arbitrary(this.min, this.max, this.min, ArrayInt64_1.substract64(this.min, logMin)));
        }
        else {
            const logGap = ArrayInt64_1.logLike64(ArrayInt64_1.substract64(this.max, this.min));
            const arbCloseToMin = new ArrayInt64Arbitrary(this.min, this.max, this.min, ArrayInt64_1.add64(this.min, logGap));
            const arbCloseToMax = new ArrayInt64Arbitrary(this.min, this.max, ArrayInt64_1.substract64(this.max, logGap), this.max);
            this.biasedArrayInt64Arbitrary = minStrictlySmallerZero
                ? new BiasNumeric_1.BiasedNumericArbitrary(arbCloseToMax, arbCloseToMin)
                : new BiasNumeric_1.BiasedNumericArbitrary(arbCloseToMin, arbCloseToMax);
        }
        return this.biasedArrayInt64Arbitrary;
    }
    withBias(freq) {
        return BiasedArbitraryWrapper_1.biasWrapper(freq, this, (originalArbitrary) => originalArbitrary.pureBiasedArbitrary());
    }
}
function arrayInt64(min, max) {
    return new ArrayInt64Arbitrary(min, max, min, max);
}
exports.arrayInt64 = arrayInt64;
