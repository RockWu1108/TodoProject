"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.bigUint = exports.bigInt = exports.bigUintN = exports.bigIntN = void 0;
const ArbitraryWithShrink_1 = require("./definition/ArbitraryWithShrink");
const BiasedArbitraryWrapper_1 = require("./definition/BiasedArbitraryWrapper");
const Shrinkable_1 = require("./definition/Shrinkable");
const BiasNumeric_1 = require("./helpers/BiasNumeric");
const ShrinkNumeric_1 = require("./helpers/ShrinkNumeric");
class BigIntArbitrary extends ArbitraryWithShrink_1.ArbitraryWithShrink {
    constructor(min, max, genMin, genMax) {
        super();
        this.min = min;
        this.max = max;
        this.genMin = genMin;
        this.genMax = genMax;
        this.biasedBigIntArbitrary = null;
    }
    wrapper(value, shrunkOnce) {
        return new Shrinkable_1.Shrinkable(value, () => this.shrink(value, shrunkOnce).map((v) => this.wrapper(v, true)));
    }
    generate(mrng) {
        return this.wrapper(mrng.nextBigInt(this.genMin, this.genMax), false);
    }
    shrink(value, shrunkOnce) {
        return ShrinkNumeric_1.shrinkBigInt(this.min, this.max, value, shrunkOnce === true);
    }
    pureBiasedArbitrary() {
        if (this.biasedBigIntArbitrary != null) {
            return this.biasedBigIntArbitrary;
        }
        this.biasedBigIntArbitrary = BiasNumeric_1.biasNumeric(this.min, this.max, BigIntArbitrary, BiasNumeric_1.bigIntLogLike);
        return this.biasedBigIntArbitrary;
    }
    withBias(freq) {
        return BiasedArbitraryWrapper_1.biasWrapper(freq, this, (originalArbitrary) => originalArbitrary.pureBiasedArbitrary());
    }
}
function bigIntN(n) {
    const min = BigInt(-1) << BigInt(n - 1);
    const max = (BigInt(1) << BigInt(n - 1)) - BigInt(1);
    return new BigIntArbitrary(min, max, min, max);
}
exports.bigIntN = bigIntN;
function bigUintN(n) {
    const min = BigInt(0);
    const max = (BigInt(1) << BigInt(n)) - BigInt(1);
    return new BigIntArbitrary(min, max, min, max);
}
exports.bigUintN = bigUintN;
function buildCompleteBigIntConstraints(constraints) {
    const DefaultPow = 256;
    const DefaultMin = BigInt(-1) << BigInt(DefaultPow - 1);
    const DefaultMax = (BigInt(1) << BigInt(DefaultPow - 1)) - BigInt(1);
    const min = constraints.min;
    const max = constraints.max;
    return {
        min: min !== undefined ? min : DefaultMin - (max !== undefined && max < BigInt(0) ? max * max : BigInt(0)),
        max: max !== undefined ? max : DefaultMax + (min !== undefined && min > BigInt(0) ? min * min : BigInt(0)),
    };
}
function extractBigIntConstraints(args) {
    if (args[0] === undefined) {
        return {};
    }
    if (args[1] === undefined) {
        const constraints = args[0];
        return constraints;
    }
    return { min: args[0], max: args[1] };
}
function bigInt(...args) {
    const constraints = buildCompleteBigIntConstraints(extractBigIntConstraints(args));
    return new BigIntArbitrary(constraints.min, constraints.max, constraints.min, constraints.max);
}
exports.bigInt = bigInt;
function bigUint(constraints) {
    const max = constraints === undefined ? undefined : typeof constraints === 'object' ? constraints.max : constraints;
    return max === undefined ? bigUintN(256) : new BigIntArbitrary(BigInt(0), max, BigInt(0), max);
}
exports.bigUint = bigUint;
